<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../css/sidebar.css">
  <link rel="stylesheet" href="../css/style.css">
  <title>Concepts</title>
</head>
<body>

  <div class="sidebar">
    <a class="" href="../index.html">Home</a>
    <a class="active" href="concepts.html">Concepts</a>
    <a class="" href="code.html">Code</a>
    <a class="" href="tool.html">Tool</a>
    <a class="" href="references.html">References</a>
  </div>

  <div class="content">
    <!-- TODO: fix header hierarchy -->
    <!--
      0th: intro
      1st: the subject and main ideas.
      2nd: bijection and interval exchange
      3rd: iterated interval exchange (construction)
      4th: Partial iterated (why ? -> 'infinite' trap)
      5th: the fast-iterated interval exchange (topology) -> +see "Code section"
      6th: conclude
     -->

    <h1>Remarks</h1>
      <ul>
        <li>This project and especially the current page are currently work in progress thus expect changes to be made.</li>
        <li>The below work closely follows the work of David Eppstein. See <a href="references.html">References</a> page.</li>
        <li>Details regarding our implementation of the below ideas can be found in the <a href="code.html">Code</a> section.</li>
      </ul>

    <h1>Introduction</h1>
      <p>
        In computer graphics,
        we are often given a 3D-space containing a set of triangles
        that we further want to render on a computer's screen.
        One of the main tasks is to determine what color will each on-screen pixel take,
        which is mostly determined by the object we want to render.
        While we could simply attribute a basic color to each object,
        in order to obtain more realistic visualizations,
        the most common technique is to resort to ray-tracing.
      </p>
      <p>
        Its idea it to start from the object we desire to render,
        and then explore different incoming light rays that land and on it,
        and finally blend their colors together in order to obtain the final color.
        However, it is not especially a simple task, or at least not fast when implemented simply.
        The number of possible incoming rays is nearly countless,
        collision detection (or ray-object intersection) is required in order to know what object the ray hit,
        what colors it mixed, take into account the number of reflections for intensity, and eventually what direction it went.
        And the whole process has to be repeated recursively for each reflection.
      </p>

      <p>
        The article we choose to present might not actually be especially useful for actual computer graphics,
        but it shares some of those ideas.
        We have a light ray, a set of mirrors, and we want to know where the ray will end up.
        Will it disappear somewhere ? Will it manage to escape a mirror labyrinth or will it loop infinitely.
      </p>

    <h1>General idea</h1>
      <p>
        The main idea behind the algorithm is to compute for every ray's directions, 
        every possible bounces with every mirrors and the location of the next collision.
        In other words, it creates a mapping predicting every possible bounces in the environnement.
        Then we apply this mapping for a given ray direction bouncing on a mirror to get the next collision.
        We called this mapping an <strong>integer interval exchange transformation</strong>, noted f(x).
        Therefore, to get the ray's direction and position after n bounces we simply have to apply n times this exchange transformation.
        This succession of n mappings is called <strong>iterated integer interval exchange transformation</strong>, noted f<sup>(n)</sup>(x).
        An optimize version, called <strong>fast iterated exchange transformation</strong>, 
        allows to compute the result of the n<sup>th</sup> mapping without computing all the previous mapping. 
        With this last algorithm, we can predict the outcomes of the ray (e.g. location and direction of the exiting ray) 
        without the intermediate bounces.
      </p>

    <h2>Hypotheses</h2>
      <p>
        In a real case application, there is an infinite number of possible reflections. 
        Therefore to apply this kind algorithm we need to defined some assumptions to simplify the problem :
        <ol>
          <li>Mirrors have integer endpoints. It means that the starting and ending point of mirrors have integer coordinates (i.e. x and y are integers).</li>
          <li>Mirrors can only be horizontal, vertical, or diagonal (at 45Â°) regarding the grid.</li>
          <li>The ray is represented as a vector,
              whose starting position and direction are specified by integer values.
              Like for mirrors, this means that the starting and ending point of the vector have integer coordinates.</li>
          <li>Mirrors' endpoints (i.e. the start and end positions) of each mirror segment, do not reflect the ray.
              When a ray hits such points it is absorbed and thus stops its journey.</li>
        </ol>
      </p>
      <p>
        With this establish, we obtain some simple but important properties:
        <ol>
          <li>Since the mirrors have only 4 possible slopes, 
              all our rays can be reflected in at most 8 possible directions.</li>
          <li>Given a ray going in a specified direction,
            it can hit any mirror in only a finite number of positions.</li>
          <li>The ray's space before and after the reflection are the same. 
            The initial ray could go through any integer point of our environnement if we translate its initial position.
            It remains true after any reflection, the new ray could go through any integer point if we translate its position.
        </ol>
        Therefore, it means there is a finite and numerable number of possible bounces in an octagonal mirror environnement making this algorithm computable.
      </p>
      <h2>Example</h2>
      <p>
        Which in summary will give us a system like represented by the image below,
        where the ray start at (7,3) (red circle) with an input direction (-1,-2),
        is reflected by mirrors represented by the blue lines,
        and escape through the right-down corner.
        Note that the blue circles represent all the possible bounces. It means all the positions
        that the light ray could reach from its 8 possibles directions.
        <figure>
          <img style="width: 350px; height: auto;" src='../images/figures/article-figure-in-tool.png' alt='missing' />
          <figcaption></figcaption>
        </figure>
        <div class='todo'><strong>TODO:</strong> Explain all observations and lemmas (following the numbers in article)</div>
      </p>

      <!-- Lemmas and so on about collisions -->
    
      <h1>Integer interval exchange transformation</h1>
      <!--With the general context now established, the observations and lemmas arising from the initial hypotheses,
      we are ready to explore the core concepts.-->
        <p>
          As explained, in our problem, the integer interval exchange transformation maps a bounce 
          (i.e. input ray's direction and coordinates of the collision with the mirror) to the "next" bounce.
          More generally, an integer interval exchange transformation consists in dividing an interval
          of integers into subintervals, then those subintervals are permuted (exchange).
          <!-- illustration from the article -->
          
          Therefore it is a bijective mapping.
          This bijective property is really important. Indeed, it allows to guarantee a solution when applying n times the transformation.
        </p>
        <figure>
          <img style="width: 300px; height: auto;"
            src='../images/figures/interval_exchange.png' alt='missing' />
          <figcaption>
            Interval exchange transformation<br>
            Note that this illustrates the principle of interval exchange transformation but is not a real example of our problem 
            since a mirror cannot reflect on itself.
            (Figure from "<a href="https://www.ics.uci.edu/~eppstein/pubs/Epp-CCCG-22c.pdf">Reflections in an Octagonal Mirror Maze</a>")
          </figcaption>
        </figure>
        <p>
          As a reminder, the idea of a <strong>bijection</strong> is, given input and output sets,
          to join each input elements to one and only one output element and vice versa.
          For instance using a line, making sure each input and each output element has one and only one incoming/outcoming line.
        </p>
        <p>To construct the integer interval exchange transformation, we assemble the mirrors on a line and 
          link every bounce (with a certain position and angle) to the next bounce.
          Therefore, we need to add this linear aggregation of mirrors 8 times (one by direction).
        </p>
        <p>
          The construction of this integer interval exchange transformation is not complete (bijective). 
          Indeed, this construction does not take into account the non-reflecting mirrors, nor the extremities of the mirrors, nor the outgoing rays.
          Therefore some adjustments need to be done to get a complete (bijective) integer interval exchange transformation.
          Those adjustments result in the <strong>partial integer interval exchange</strong>.
        </p>

    <h1>Partial integer interval exchange</h1>
    <p>
        The previous section highlights 3 problems in the current integer interval exchange:
        <ol>
          <li>outgoing rays</li>
          <li>non-reflective mirror</li>
          <li>mirrors' endpoints</li>
        </ol>
    </p>

    <p>When a mirror reflects a ray out of the environnement, it is not mapped to a "next" bounce (or collision).
      Therefore, to handle the <strong>outgoing rays</strong>, we simply surrounds the environnement with a big absorbing box.
      Then we can considered that the outgoing ray is mapped to a non-reflective surface on the border of the environnement.
      The problem is still not resolved since the non-reflective surfaces are not yet taken into account.
    </p>

    <p>The <strong>non-reflective</strong> surfaces break the bijectivity of the integer interval exchange transformation.
    To solve this problem we simply <strong>virtually</strong> mapped a non-reflective surface as it was reflective.
    </p>

    <p>The <strong>mirrors' endpoints</strong> break the bijectivity as the non-reflective surfaces. 
      To solve this problem we <strong>virtually</strong> mapped a mirror's endpoint reflection as it flips back the ray (i.e. opposite direction).
    </p>

    <p>At this point, we obtain a bijective mapping. 
      However, this mapping is incorrect since we reflect collisions, even on non-reflective surfaces.
      The <strong>partial integer interval exchange</strong> solves this problem by adding new intervals 
      that will act like an "infinite trap" for the ray.
      <br>
      By the <strong>Observation 5</strong>, we compute n, the total number of possibles bounces which gives a majoration for cycles' size of the bijective mapping.
      It is useless to apply more than n times the interval exchange transformation because the ray goes out of the environnement before or is caught in an infinite loop.
      Therefore, a n-depth trap is considered to be "infinte" since we will not compute more than n steps.
      <br>
      Basically, the partial integer interval exchange proposes to add, for non-reflective element (the 3 kind of elements cited above), 
      n new "virtual" element between this non-reflective element and its "virtual" reflection.
      Consequently, we obtain a complete bijective mapping for all bounces and we are sure that non-reflective element or not map to a reflective element 
      in less than n steps.
      <!-- GRAPHICAL ILLUSTRATION + ILLUSTRATION intervals numbers-->
    </p>

    <h1>Fast iterated interval exchange using topology</h1>

      <p>
        In order to make the iterated exchange process faster,
        the proposed idea is to reduce the transformation into a problem of computational topology.
      </p>

      <h2>Interval exchange as triangulated surface</h2>
      <p>
        As illustrated by the image below,
        the idea is to place the decomposition of the initial interval into subintervals at the top,
        and the corresponding permutation of those subintervals at the bottom.
        Then, we glue each subinterval with its corresponding subinterval after permutation (i.e per label).
        For instance, the top's first subinterval labelled by <b>a</b> will be joined with the last bottom subinterval <b>a</b>.
        As those intervals are made of integers, we will make those numbers stand out by drawing a vertical blue line
        from each integer. In the example, as the integer range goes from 0 to 14 (from left to right), we thus have 15 blue lines.
        Descending this line vertically from a top's certain integer, will give its corresponding permutation value at the bottom.
        Thus, starting from number 0 at the top (<b>a</b> subinterval), we will descend into the <b>b</b> subinterval, giving the number 4. 

        If you follow this idea recursively (descend from 4 onto <b>d</b> and obtaining 9, etc.) in our example you will end up back at your starting position as the exchange is a bijection and cyclic.

        All those blue lines, according to our previous glueing,
        actually form a single blue line called the <span class="normal_curve">normal curve</span>.
      </p>
      
      <p class="note">
        Note that an exchange can have multiple cycles, 
        in that case we will say that a <span class="normal_curve">normal curve</span> is composed
        of multiple <span class="normal_arc">normal arcs</span>.
        But for now, we will only focus on a single cycle.
      </p>

      <p>
        Next, the surface is divided into a certain number of horizontal lines,
        and triangulated in such a way that each blue line crosses only one triangle edge
        between two consecutive horizontal lines.
        To be more precise, the surface must have a central horizontal line (edge) that will have only two vertices, 
        placed on its borders (or a single vertex if we view the surface as glued by its vertical borders).
        The goal will be to add enough horizontal lines in between such that the above's property about blue 
        lines and triangle edges is respected.
      </p>

      <figure>
        <img style="width: 400px; height: auto;"
          src='../images/figures/3-Figure2-1.png' alt='missing' />
        <figcaption>
          Interval exchange as triangulated manifold.<br>
          Note that it does not actually represent mirror subintervals,<br>
          as it maps a part of the <b>d</b> subinterval back to <b>d</b>,<br>
           but the overall idea remains the same.<br>
          (Figure from "<a href="https://arxiv.org/pdf/2112.11607.pdf">The Complexity of Iterated Reversible Computation</a>")
        </figcaption>
      </figure>


      <h2>Traversing the normal curve</h2>

        <p>
          Consider mainly the middle horizontal edge of the surface and also the blue <span class="normal_curve">normal curve</span>.
          We start at a certain position of the horizontal line,
          that we will call the <span class="edge_coord">edge coordinates</span>,
          that correspond to the initial number we want to iterate: x in f<sup>(n)</sup>(x).
          From there, basically, the idea is to convert those <span class="edge_coord">edge coordinates</span> into <span class="arc_coord">arc coordinates</span>.
        </p>
        <p class="note">
          <span class="arc_coord">Arc coordinates</span> represent the i<sup>th</sup> edge
          that a <span class="normal_arc">normal arc</span> has crossed/hit since an arbitrary initial starting position.
        </p>
        <p>
          Once those are obtained, we add '<b>2ns</b>' to those coordinates.
          '<b>n</b>' is the number of iterations we want to execute (recall f<sup>(n)</sup>(x)).
          '<b>s</b>' is the number of edges crossed from the horizontal central edge to the horizontal top edge (4 in our example),
          which we multiply by 2 in order to obtain the number of edges crossed from top to bottom.
          We modulo the whole operation as the <span class="arc_coord">arc coordinates</span> are cyclic by definition.
          Then, we simply convert back the <span class="arc_coord">arc coordinates</span>
          to the <span class="edge_coord">edge coordinates</span>
          in order to obtain the final result of the iteration.

          For example, if we initialized the <span class="arc_coord">arc coordinates</span> to be the edge labelled by <b>a</b>,
          the <span class="edge_coord">edge coordinates</span> x = 0 converted into <span class="arc_coord">arc coordinates</span> would be 4.
          By computing 4 + 2s (where s = 4), we obtain <span class="arc_coord">arc coordinates</span> 12,
          which converted back to the <span class="edge_coord">edge coordinates</span> give us x = 4 as seen before.
        </p>
        <p>
          However in our mirror problem, there could have several cycles
          and thus multiple <span class="normal_arc">normal arcs</span>.

          In order to take those into account, retain simply that we have to apply additional topological subroutines,
          in order to first determine to which <span>normal arc</span> our x value belongs and convert the value to the arc's scope.

          The conversion between coordinates can be obtained through algorithms presented in the section 6 of the "<a href="https://jeffe.cs.illinois.edu/pubs/pdf/tracing.pdf">Tracing Compressed Curves in Triangulated Surfaces</a>" article that we will omit here.
        </p>


  </div>

</body>
</html>
